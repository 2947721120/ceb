{"version":3,"file":"ceb-feature-template.min.js","sources":["../src/ceb-feature-template.js"],"names":["g","factory","exports","module","define","amd","cebFeatureTemplate","this","feature","el","__cebTemplateScope","apply","tpl","isHandleLightDOM","isNodeReferences","newCebContentId","lightChildren","bindedNodes","template","oldCebContentId","getAttribute","lightDomNode","querySelector","childNodes","length","push","removeChild","counter","replace","setAttribute","result","nodesRegEx","exec","id","property","newAtt","attribute","innerHTML","contentNode","forEach","node","appendChild","entry","setup","struct","builder","options","search","contentRegEx","wrap","next","arguments"],"mappings":";;;;;;;;CAiBC,SAAUA,EAAGC,GACV,YAGuB,iBAAZC,SACPC,OAAOD,QAAUD,IACQ,kBAAXG,SAAyBA,OAAOC,IAC9CD,OAAO,0BAA4BH,GAEnCD,EAAEM,mBAAqBL,KAG7BM,KAAM,WACJ,YAKA,SAASC,GAAQC,GAIb,MAHKA,GAAGC,qBACJD,EAAGC,uBAEAD,EAAGC,mBAed,QAASC,GAAMC,EAAKH,EAAII,EAAkBC,GACtC,GAEIC,GAFAC,KACAC,KAEAC,EAAWN,CAEf,IAAIC,EAAkB,CAMlB,IAJA,GAAIM,GAAkBV,EAAGW,aAAa,sBAElCC,EAAeZ,EAAGa,cAAc,IAAMH,EAAkB,MAAQV,EAE7DY,EAAaE,WAAWC,OAAS,GACpCR,EAAcS,KAAKJ,EAAaK,YAAYL,EAAaE,WAAW,IAIxER,GAAkB,OAAUY,KAAa,WAEzCT,EAAWA,EAASU,QAAQ,eAAgB,IAAMb,GAElDN,EAAGoB,aAAa,qBAAsBd,GAG1C,GAAID,EAGA,IADA,GAAIgB,GAC4C,QAAxCA,EAASC,EAAWC,KAAKd,KAAqB,CAClD,GAAIe,GAAKN,IACLO,EAAWJ,EAAO,GAClBK,EAAS,OAASF,EAAK,MAC3Bf,GAAWA,EAASU,QAAQ,WAAY,IAAMO,GAC9ClB,EAAYQ,MACRW,UAAWD,EACXD,SAAUA,IAStB,GAHAzB,EAAG4B,UAAYnB,EAGXL,EAAkB,CAClB,GAAIyB,GAAc7B,EAAGa,cAAc,IAAMP,EAAkB,IAC3DC,GAAcuB,QAAQ,SAAUC,GAC5BF,EAAYG,YAAYD,KAI5B1B,GAEAG,EAAYsB,QAAQ,SAAUG,GAC1BlC,EAAQC,GAAIiC,EAAMR,UAAYzB,EAAGa,cAAc,IAAMoB,EAAMN,UAAY,OAQnF,QAASO,GAAMC,EAAQC,EAASC,GAC5B,GAAIlC,GAAMkC,EAAQ5B,UAAY,GAC1BL,EAAgD,KAA7BD,EAAImC,OAAOC,GAC9BlC,EAA8C,KAA3BF,EAAImC,OAAOhB,EAClCc,GAAQI,KAAK,kBAAmB,SAAUC,EAAMzC,GAC5CE,EAAMC,EAAKH,EAAII,EAAkBC,GACjCoC,EAAKC,aA5Eb,GAAIxB,GAAU,EAGVI,EAAa,uBAGbiB,EAAe,gBA2EnB,OAFAxC,GAAQmC,MAAQA,EAETnC","sourcesContent":["// # ceb-feature-template.js\n\n// ## Light DOM\n//\n// The template can contains a node having the attribute `ceb-content`.\n// The marked node is intend to host the light DOM of the current element at the end of the templating process.\n//\n// If the template doesn't contain this node, the light DOM will be lost.\n//\n// ## DOM nodes references\n//\n// The template can contains nodes having the attribute `ceb-ref`.\n// The marked nodes will be available at the end of the templating process from the feature function (`feature(el)`).\n//\n// That means, if a node has the attribute `ceb-ref=\"header\"`.\n// It will be available via `feature(el).header`.\n\n(function (g, factory) {\n    'use strict';\n\n    /* istanbul ignore next */\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb-feature-template', [], factory);\n    } else {\n        g.cebFeatureTemplate = factory();\n    }\n\n}(this, function () {\n    'use strict';\n\n    // ## feature function\n\n    // The template feature's function returns the nodes' reference of the template.\n    function feature(el) {\n        if (!el.__cebTemplateScope) {\n            el.__cebTemplateScope = {};\n        }\n        return el.__cebTemplateScope;\n    }\n\n    // ## Templating stuff\n\n    // The counter is used to generate unique DOM's id.\n    var counter = 0;\n\n    // Regex to detect the *ceb-ref* attributes\n    var nodesRegEx = /ceb\\-ref=\\W*(\\w*)/igm;\n\n    // Regex to detect the *ceb-content* attribute\n    var contentRegEx = /ceb\\-content/im;\n\n    // Apply a template to an element.\n    function apply(tpl, el, isHandleLightDOM, isNodeReferences) {\n        var lightChildren = [],\n            bindedNodes = [],\n            newCebContentId,\n            template = tpl;\n\n        if (isHandleLightDOM) {\n            // When a node is cloned the light DOM of the cloned has to be retrived\n            var oldCebContentId = el.getAttribute('ceb-old-content-id');\n            // Get the light DOM\n            var lightDomNode = el.querySelector('[' + oldCebContentId + ']') || el;\n            // Remove the light DOM nodes from the element\n            while (lightDomNode.childNodes.length > 0) {\n                lightChildren.push(lightDomNode.removeChild(lightDomNode.childNodes[0]));\n            }\n\n            // Generate the new content's id value\n            newCebContentId = 'ceb-' + (counter++) + '-content';\n            // Update the tempate to contains the content's id\n            template = template.replace(' ceb-content', ' ' + newCebContentId);\n            // Keep a value of the content's id value if the node is cloned\n            el.setAttribute('ceb-old-content-id', newCebContentId);\n        }\n\n        if (isNodeReferences) {\n            // Update the template to detect the DOM nodes references.\n            var result;\n            while ((result = nodesRegEx.exec(template)) !== null) {\n                var id = counter++;\n                var property = result[1];\n                var newAtt = 'ceb-' + id + '-ref';\n                template = template.replace(' ceb-ref', ' ' + newAtt);\n                bindedNodes.push({\n                    attribute: newAtt,\n                    property: property\n                });\n            }\n        }\n\n        // Make alive the template.\n        el.innerHTML = template;\n\n        // Push the light DOM nodes into the element\n        if (isHandleLightDOM) {\n            var contentNode = el.querySelector('[' + newCebContentId + ']');\n            lightChildren.forEach(function (node) {\n                contentNode.appendChild(node);\n            });\n        }\n\n        if (isNodeReferences) {\n            // Get the reference nodes.\n            bindedNodes.forEach(function (entry) {\n                feature(el)[entry.property] = el.querySelector('[' + entry.attribute + ']');\n            });\n        }\n    }\n\n    // ## Setup function\n\n    // The templeting process is done before the call of the `createdCallback` method defined in the structure.\n    function setup(struct, builder, options) {\n        var tpl = options.template || '';\n        var isHandleLightDOM = tpl.search(contentRegEx) !== -1;\n        var isNodeReferences = tpl.search(nodesRegEx) !== -1;\n        builder.wrap('createdCallback', function (next, el) {\n            apply(tpl, el, isHandleLightDOM, isNodeReferences);\n            next(arguments);\n        });\n    }\n    feature.setup = setup;\n\n    return feature;\n}));\n"]}