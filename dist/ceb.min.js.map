{"version":3,"file":"ceb.min.js","sources":["../src/ceb.js"],"names":["g","factory","exports","module","define","amd","ceb","this","emptyFn","listValues","o","Object","getOwnPropertyNames","map","propName","fromCamelCaseToHyphenCase","value","split","part","charAt","toLowerCase","slice","join","compareLevels","a","b","level","applyAttributeValue","el","attName","isBoolean","hasAttribute","setAttribute","removeAttribute","undefined","getAttribute","accessorFactory","wrappers","wrapped","stack","sort","reduce","previous","current","bind","apply","arguments","attributeAccessorSetFactory","setter","attValue","call","attributeAccessorGetFactory","getter","methodFactory","args","Array","prototype","length","sanitizeStructure","struct","create","HTMLElement","features","interceptors","properties","methods","assign","createdCallback","attachedCallback","detachedCallback","attributeChangedCallback","setupFeatures","builder","tagName","registered","forEach","feature","fn","setup","options","createAttributesHash","filter","property","createDefinedPropertiesHash","definedProperty","configurable","enumerable","attribute","set","get","hasOwnProperty","writable","setStack","getStack","createMethodsHash","methName","baseStructFactory","builtInFeatures","delegate","valueInitializer","sanitizeProperty","name","params","api","testing","build","definedProperties","attributes","defineProperties","document","registerElement","delegableSetAccessorInterceptor","next","target","querySelector","targetPropName","targetAttName","delegableGetAccessorInterceptor","result","intercept","createdCallbackWrapper","attributeChangedCallbackWrapper","oldVal","newVal","wrap","isNaN","push","setFn","getFn","anExtend","aProto","someProperties","sanitizedProperties","someMethods","register","_testing"],"mappings":"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","sourcesContent":["(function (g, factory) {\n    /* globals module:0, define:0 */\n\n    'use strict';\n\n    /* istanbul ignore next */\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb', [], factory);\n    } else {\n        g.ceb = factory();\n    }\n\n}(this, function () {\n\n    'use strict';\n\n    var testing = {};\n\n    /* TOOLS */\n\n    function emptyFn() {\n        return function () {};\n    }\n    testing.emptyFn = emptyFn;\n\n    function listValues(o) {\n        return Object.getOwnPropertyNames(o).map(function (propName) {\n            return o[propName];\n        });\n    }\n    testing.listValues = listValues;\n\n    // transform property notation to attribute notation\n    function fromCamelCaseToHyphenCase(value) {\n        return value.split(/(?=[A-Z])/).map(function (part) {\n            return part.charAt(0).toLowerCase() + part.slice(1);\n        }).join('-');\n    }\n    testing.fromCamelCaseToHyphenCase = fromCamelCaseToHyphenCase;\n\n    function compareLevels(a, b) {\n        return a.level - b.level;\n    }\n    testing.compareLevels = compareLevels;\n\n    function applyAttributeValue(el, attName, value, isBoolean) {\n        if (isBoolean) {\n            if (value && !el.hasAttribute(attName)) {\n                el.setAttribute(attName, '');\n            } else if (!value && el.hasAttribute(attName)) {\n                el.removeAttribute(attName);\n            }\n        } else {\n            if ((value === null || value === undefined) && el.hasAttribute(attName)) {\n                el.removeAttribute(attName);\n            } else if ((value !== null && value !== undefined) && el.getAttribute(attName) !== value) {\n                el.setAttribute(attName, value);\n            }\n        }\n    }\n    testing.applyAttributeValue = applyAttributeValue;\n\n    function accessorFactory(wrappers, wrapped) {\n        var stack = wrappers.sort(compareLevels);\n        return function accessor() {\n            var el = this;\n            return stack.reduce(function (previous, current) {\n                return current.bind(el, previous, el);\n            }, wrapped.bind(el, el)).apply(el, arguments);\n        };\n    }\n    testing.accessorFactory = accessorFactory;\n\n    function attributeAccessorSetFactory(attName, setter, isBoolean) {\n        return function attributeAccessorSet(el, value) {\n            var attValue = value;\n            if (setter) {\n                attValue = setter.call(el, el, value);\n            }\n            applyAttributeValue(el, attName, attValue, isBoolean);\n        };\n    }\n    testing.attributeAccessorSetFactory = attributeAccessorSetFactory;\n\n    function attributeAccessorGetFactory(attName, getter, isBoolean) {\n        return function attributeAccessorGet(el) {\n            var value = isBoolean ? el.hasAttribute(attName) : el.getAttribute(attName);\n            if (getter) {\n                value = getter.call(el, el, value);\n            }\n            return value;\n        };\n    }\n    testing.attributeAccessorGetFactory = attributeAccessorGetFactory;\n\n    function methodFactory(wrappers, wrapped) {\n        var stack = wrappers.sort(compareLevels);\n        return function () {\n            var el = this;\n            return stack.reduce(function (previous, current) {\n                return current.bind(el, function next(args) {\n                    return previous.apply(el, Array.prototype.slice.call(args).slice(2, args.length));\n                }, el);\n            }, wrapped.bind(el, el)).apply(el, arguments);\n        };\n    }\n    testing.methodFactory = methodFactory;\n\n    /* BUILD LIFE CYCLE */\n\n    function sanitizeStructure(struct) {\n        struct.prototype = struct.prototype || Object.create(HTMLElement.prototype);\n        struct.features = struct.features || [];\n        struct.interceptors = struct.interceptors || [];\n        struct.wrappers = struct.wrappers || [];\n        struct.properties = struct.properties || {};\n        struct.methods = Object.assign({\n            createdCallback: emptyFn(),\n            attachedCallback: emptyFn(),\n            detachedCallback: emptyFn(),\n            attributeChangedCallback: emptyFn()\n        }, struct.methods);\n        return struct;\n    }\n    testing.sanitizeStructure = sanitizeStructure;\n\n    function setupFeatures(struct) {\n        var b = builder(struct.tagName, {\n            struct: struct,\n            registered: true\n        });\n        struct.features.sort(compareLevels).forEach(function (feature) {\n            if (feature.fn && feature.fn.setup) {\n                feature.fn.setup(struct, b, feature.options);\n            }\n        });\n    }\n    testing.setupFeatures = setupFeatures;\n\n    function createAttributesHash(struct) {\n        return listValues(struct.properties).filter(function (property) {\n            return property.attName;\n        }).reduce(function (previous, current) {\n            previous[current.attName] = current;\n            return previous;\n        }, {});\n    }\n    testing.createAttributesHash = createAttributesHash;\n\n    function createDefinedPropertiesHash(struct) {\n        return listValues(struct.properties).map(function (property) {\n            // default parameters\n            var definedProperty = {\n                configurable: false,\n                enumerable: true\n            };\n\n            if (property.attribute) {\n                // handle properties linked to an attribute\n                property.set = attributeAccessorSetFactory(property.attName, property.setter, !!property.attribute.boolean);\n                property.get = attributeAccessorGetFactory(property.attName, property.getter, !!property.attribute.boolean);\n            } else if (property.hasOwnProperty('value') && property.hasOwnProperty('writable') && !property.writable) {\n                // handle constants\n                definedProperty.value = property.value;\n                definedProperty.writable = false;\n            } else if (!property.set && !property.get) {\n                definedProperty.writable = true;\n            }\n\n            if (!definedProperty.hasOwnProperty('writable')) {\n                // handle setter and getter\n                var interceptors = struct.interceptors[property.propName] || {};\n                if (property.set) {\n                    var setStack = interceptors.set || [];\n                    definedProperty.set = accessorFactory(setStack, property.set);\n                }\n                if (property.get) {\n                    var getStack = interceptors.get || [];\n                    definedProperty.get = accessorFactory(getStack, property.get);\n                }\n            }\n\n            return Object.assign(property, {\n                property: definedProperty\n            });\n        }).reduce(function (previous, current) {\n            previous[current.propName] = current.property;\n            return previous;\n        }, {});\n    }\n    testing.createDefinedPropertiesHash = createDefinedPropertiesHash;\n\n    function createMethodsHash(struct) {\n        return Object.getOwnPropertyNames(struct.methods).map(function (methName) {\n            var stack = struct.wrappers[methName] || [];\n            var fn = struct.methods[methName];\n            return {\n                methName: methName,\n                fn: methodFactory(stack, fn)\n            };\n        }).reduce(function (previous, current) {\n            previous[current.methName] = current.fn;\n            return previous;\n        }, {});\n    }\n    testing.createMethodsHash = createMethodsHash;\n\n    /* BUILD */\n\n    var build = function build(struct) {\n        sanitizeStructure(struct);\n        setupFeatures(struct);\n\n        struct.definedProperties = createDefinedPropertiesHash(struct);\n        struct.attributes = createAttributesHash(struct);\n        struct.methods = createMethodsHash(struct);\n\n        Object.defineProperties(struct.prototype, struct.definedProperties);\n        Object.assign(struct.prototype, struct.methods);\n\n        return document.registerElement(struct.tagName, struct);\n    };\n    testing.build = build;\n\n    /* FEATURES */\n\n    var builtInFeatures = {};\n    testing.builtInFeatures = builtInFeatures;\n\n    builtInFeatures.delegate = emptyFn();\n    builtInFeatures.delegate.delegableSetAccessorInterceptor = function (property, next, el, value) {\n        next(value);\n        var target = el.querySelector(property.delegate.target);\n        /* istanbul ignore else  */\n        if (target) {\n            var targetPropName = property.delegate.property;\n            var targetAttName = property.delegate.attribute;\n            if (!targetPropName && !targetAttName) {\n                targetPropName = property.propName;\n                targetAttName = property.attName;\n            }\n            var isBoolean = property.attribute && !!property.attribute.boolean;\n            if (property.delegate.hasOwnProperty('boolean')) {\n                isBoolean = property.delegate.boolean;\n            }\n            if (targetAttName) {\n                applyAttributeValue(target, targetAttName, value, isBoolean);\n            } else {\n                target[targetPropName] = value;\n            }\n        }\n    };\n    builtInFeatures.delegate.delegableGetAccessorInterceptor = function (property, next, el, value) {\n        var result = next(value);\n        var target = el.querySelector(property.delegate.target);\n        /* istanbul ignore else  */\n        if (target) {\n            var targetPropName = property.delegate.property;\n            var targetAttName = property.delegate.attribute;\n            if (!targetPropName && !targetAttName) {\n                targetPropName = property.propName;\n                targetAttName = property.attName;\n            }\n            var isBoolean = property.attribute && !!property.attribute.boolean;\n            if (property.delegate.hasOwnProperty('boolean')) {\n                isBoolean = property.delegate.boolean;\n            }\n            if (targetAttName) {\n                result = isBoolean ? target.hasAttribute(targetAttName) : target.getAttribute(targetAttName);\n            } else {\n                result = target[targetPropName];\n            }\n        }\n        return result;\n    };\n    builtInFeatures.delegate.setup = function (struct, builder) {\n        var delegableSetAccessorInterceptor = builtInFeatures.delegate.delegableSetAccessorInterceptor;\n        var delegableGetAccessorInterceptor = builtInFeatures.delegate.delegableGetAccessorInterceptor;\n        // keep only properties configured for delegation\n        listValues(struct.properties).filter(function (property) {\n            return property.delegate;\n        }).forEach(function (property) {\n            // intercept the setter\n            if (!property.attName) {\n                property.set = property.set || emptyFn();\n                property.get = property.get || emptyFn();\n            }\n            builder.intercept(\n                property.propName,\n                delegableSetAccessorInterceptor.bind(builtInFeatures.delegate, property),\n                delegableGetAccessorInterceptor.bind(builtInFeatures.delegate, property)\n            );\n        });\n    };\n\n    builtInFeatures.valueInitializer = emptyFn();\n    builtInFeatures.valueInitializer.createdCallbackWrapper = function (struct, next, el) {\n        next(arguments);\n        listValues(struct.properties).forEach(function (property) {\n            if (property.attName) {\n                if (el.hasAttribute(property.attName)) {\n                    el[property.propName] = property.attribute.boolean ? true : el.getAttribute(property.attName);\n                } else if (property.hasOwnProperty('value')) {\n                    applyAttributeValue(el, property.attName, property.value, property.attribute.boolean);\n                }\n            } else if (property.hasOwnProperty('value') && property.writable) {\n                el[property.propName] = property.value;\n            }\n        });\n    };\n    builtInFeatures.valueInitializer.attributeChangedCallbackWrapper = function (struct, next, el, attName, oldVal, newVal) {\n        var property = struct.attributes[attName];\n        if (property) {\n            var value = newVal;\n            if (property.attribute.boolean) {\n                value = typeof newVal === 'string' ? true : false;\n            }\n            el[property.propName] = value;\n        }\n        next(arguments);\n    };\n    builtInFeatures.valueInitializer.setup = function (struct, builder) {\n        var createdCallbackWrapper = builtInFeatures.valueInitializer.createdCallbackWrapper;\n        var attributeChangedCallbackWrapper = builtInFeatures.valueInitializer.attributeChangedCallbackWrapper;\n        builder.wrap('createdCallback', createdCallbackWrapper.bind(builtInFeatures.valueInitializer, struct));\n        builder.wrap('attributeChangedCallback', attributeChangedCallbackWrapper.bind(builtInFeatures.valueInitializer, struct));\n    };\n\n    /* BUILDER */\n\n    function baseStructFactory() {\n        return {\n            properties: {},\n            methods: {},\n            wrappers: [],\n            interceptors: [],\n            features: [{\n                fn: builtInFeatures.delegate,\n                level: -2\n            }, {\n                fn: builtInFeatures.valueInitializer,\n                level: -1\n            }]\n        };\n    }\n    testing.baseStructFactory = baseStructFactory;\n\n    function sanitizeProperty(property) {\n        if (property.attribute) {\n            property.attName = property.attribute.name || fromCamelCaseToHyphenCase(property.propName);\n        }\n        property.writable = property.hasOwnProperty('writable') ? property.writable : true;\n        return property;\n    }\n    testing.sanitizeProperty = sanitizeProperty;\n\n    var builder = function builder(tagName, params) {\n        var struct = params && params.struct ? sanitizeStructure(params.struct) : baseStructFactory();\n        struct.tagName = tagName;\n        var registered = params && params.hasOwnProperty('registered') ? params.registered : false;\n        var api = {};\n        // WRAPPER\n        api.wrap = function (methName, fn, level) {\n            if (!struct.wrappers[methName]) {\n                struct.wrappers[methName] = [];\n            }\n            fn.level = isNaN(level) ? 0 : level;\n            struct.wrappers[methName].push(fn);\n            return api;\n        };\n        api.intercept = function (propName, setFn, getFn, level) {\n            if (!struct.interceptors[propName]) {\n                struct.interceptors[propName] = {\n                    set: [],\n                    get: []\n                };\n            }\n            if (setFn) {\n                setFn.level = isNaN(level) ? 0 : level;\n                struct.interceptors[propName].set.push(setFn);\n            }\n            if (getFn) {\n                getFn.level = isNaN(level) ? 0 : level;\n                struct.interceptors[propName].get.push(getFn);\n            }\n            return api;\n        };\n        // INTEGRATION\n        api['extends'] = function (anExtend) {\n            struct['extends'] = anExtend;\n            return api;\n        };\n        api.prototype = function (aProto) {\n            struct.prototype = aProto;\n            return api;\n        };\n        // FELDS\n        api.properties = function (someProperties) {\n\n            var sanitizedProperties = Object.getOwnPropertyNames(someProperties).map(function (propName) {\n                return Object.assign(someProperties[propName], {\n                    propName: propName\n                });\n            }).map(sanitizeProperty).reduce(function (previous, current) {\n                previous[current.propName] = current;\n                return previous;\n            }, {});\n\n            Object.assign(struct.properties, sanitizedProperties);\n\n            return api;\n        };\n        api.methods = function (someMethods) {\n            Object.assign(struct.methods, someMethods);\n            return api;\n        };\n        // FEATURES\n        api.feature = function (fn, options, level) {\n            struct.features.push({\n                fn: fn,\n                options: options,\n                level: isNaN(level) ? 0 : level\n            });\n            return api;\n        };\n        api.register = function () {\n            if (!registered) {\n                registered = true;\n                return build(struct);\n            }\n        };\n        api.get = function () {\n            return struct;\n        };\n        return api;\n    };\n    testing.builder = builder;\n\n    function factory(params) {\n        var api = {};\n        api.name = function (tagName) {\n            return builder(tagName, params);\n        };\n        return api;\n    }\n    factory._testing = testing;\n\n    return factory;\n}));\n"]}