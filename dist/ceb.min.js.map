{"version":3,"file":"ceb.min.js","sources":["../src/ceb.js"],"names":["g","factory","exports","module","define","amd","ceb","this","emptyFn","listValues","object","o","Object","getOwnPropertyNames","map","propName","fromCamelCaseToHyphenCase","value","split","part","charAt","toLowerCase","slice","join","compareLevels","a","b","level","applyAttributeValue","el","attName","isBoolean","hasAttribute","setAttribute","removeAttribute","undefined","getAttribute","accessorFactory","wrappers","wrapped","stack","sort","reduce","previous","current","bind","apply","arguments","attributeAccessorSetFactory","originalSet","attValue","call","attributeAccessorGetFactory","originalGet","methodFactory","args","Array","prototype","length","sanitizeStructure","struct","create","HTMLElement","features","interceptors","methods","assign","createdCallback","attachedCallback","detachedCallback","attributeChangedCallback","setupFeatures","builder","tagName","registered","forEach","feature","fn","setup","options","createAttributesHash","properties","filter","property","createDefinedPropertiesHash","definedProperty","configurable","enumerable","attribute","set","get","hasOwnProperty","writable","setStack","getStack","createMethodsHash","methName","baseStructFactory","builtInFeatures","delegate","valueInitializer","sanitizeProperty","name","params","api","start","testing","build","definedProperties","attributes","defineProperties","document","registerElement","delegableAccessorInterceptor","next","target","querySelector","targetPropName","targetAttName","intercept","createdCallbackWrapper","attributeChangedCallbackWrapper","oldVal","newVal","wrap","isNaN","push","setFn","getFn","anExtend","aProto","someProperties","sanitizedProperties","someMethods","register","_testing"],"mappings":"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","sourcesContent":["/* istanbul ignore next */\n(function (g, factory) {\n    /* globals module:0, define:0 */\n\n    'use strict';\n\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb', [], factory);\n    } else {\n        g.ceb = factory();\n    }\n\n}(this, function () {\n\n    'use strict';\n\n    var testing = {};\n\n    /* TOOLS */\n\n    function emptyFn() {\n        return function () {};\n    }\n    testing.emptyFn = emptyFn;\n\n    function listValues(object) {\n        var o = object || {};\n        return Object.getOwnPropertyNames(o).map(function (propName) {\n            return o[propName];\n        });\n    }\n    testing.listValues = listValues;\n\n    // transform property notation to attribute notation\n    function fromCamelCaseToHyphenCase(value) {\n        return value.split(/(?=[A-Z])/).map(function (part) {\n            return part.charAt(0).toLowerCase() + part.slice(1);\n        }).join('-');\n    }\n    testing.fromCamelCaseToHyphenCase = fromCamelCaseToHyphenCase;\n\n    function compareLevels(a, b) {\n        return a.level > b.level;\n    }\n    testing.compareLevels = compareLevels;\n\n    function applyAttributeValue(el, attName, value, isBoolean) {\n        if (isBoolean) {\n            if (value && !el.hasAttribute(attName)) {\n                el.setAttribute(attName, '');\n            } else if (!value && el.hasAttribute(attName)) {\n                el.removeAttribute(attName);\n            }\n        } else {\n            if ((value === null || value === undefined) && el.hasAttribute(attName)) {\n                el.removeAttribute(attName);\n            } else if ((value !== null && value !== undefined) && el.getAttribute(attName) !== value) {\n                el.setAttribute(attName, value);\n            }\n        }\n    }\n    testing.applyAttributeValue = applyAttributeValue;\n\n    function accessorFactory(wrappers, wrapped) {\n        var stack = wrappers.sort(compareLevels);\n        return function () {\n            var el = this;\n            return stack.reduce(function (previous, current) {\n                return current.bind(el, previous, el);\n            }, wrapped.bind(el, el)).apply(el, arguments);\n        };\n    }\n    testing.accessorFactory = accessorFactory;\n\n    function attributeAccessorSetFactory(attName, originalSet, isBoolean) {\n        return function (el, value) {\n            var attValue = value;\n            if (originalSet) {\n                attValue = originalSet.call(el, el, value);\n            }\n            applyAttributeValue(el, attName, attValue, isBoolean);\n        };\n    }\n    testing.attributeAccessorSetFactory = attributeAccessorSetFactory;\n\n    function attributeAccessorGetFactory(attName, originalGet, isBoolean) {\n        return function (el) {\n            var value = isBoolean ? el.hasAttribute(attName) : el.getAttribute(attName);\n            if (originalGet) {\n                value = originalGet.call(el, el, value);\n            }\n            return value;\n        };\n    }\n    testing.attributeAccessorGetFactory = attributeAccessorGetFactory;\n\n    function methodFactory(wrappers, wrapped) {\n        var stack = wrappers.sort(compareLevels);\n        return function () {\n            var el = this;\n            return stack.reduce(function (previous, current) {\n                return current.bind(el, function next(args) {\n                    var a = args || [];\n                    return previous.apply(el, Array.prototype.slice.call(a).slice(2, a.length));\n                }, el);\n            }, wrapped.bind(el, el)).apply(el, arguments);\n        };\n    }\n    testing.methodFactory = methodFactory;\n\n    /* BUILD LIFE CYCLE */\n\n    function sanitizeStructure(struct) {\n        struct.prototype = struct.prototype || Object.create(HTMLElement.prototype);\n        struct.features = struct.features || [];\n        struct.interceptors = struct.interceptors || [];\n        struct.wrappers = struct.wrappers || [];\n\n        struct.methods = Object.assign({\n            createdCallback: emptyFn(),\n            attachedCallback: emptyFn(),\n            detachedCallback: emptyFn(),\n            attributeChangedCallback: emptyFn()\n        }, struct.methods);\n    }\n    testing.sanitizeStructure = sanitizeStructure;\n\n    function setupFeatures(struct) {\n        var b = builder(struct.tagName, {\n            struct: struct,\n            registered: true\n        });\n        struct.features.sort(compareLevels).forEach(function (feature) {\n            if (feature.fn && feature.fn.setup) {\n                feature.fn.setup(struct, b, feature.options);\n            }\n        });\n    }\n    testing.setupFeatures = setupFeatures;\n\n    function createAttributesHash(struct) {\n        return listValues(struct.properties).filter(function (property) {\n            return property.attName;\n        }).reduce(function (previous, current) {\n            previous[current.attName] = current;\n            return previous;\n        }, {});\n    }\n    testing.createAttributesHash = createAttributesHash;\n\n    function createDefinedPropertiesHash(struct) {\n        return listValues(struct.properties).map(function (property) {\n            // default parameters\n            var definedProperty = {\n                configurable: false,\n                enumerable: true\n            };\n\n            if (property.attribute) {\n                // handle properties linked to an attribute\n                var originalSet = property.set;\n                var originalGet = property.get;\n                property.set = attributeAccessorSetFactory(property.attName, originalSet, !!property.attribute.boolean);\n                property.get = attributeAccessorGetFactory(property.attName, originalGet, !!property.attribute.boolean);\n            } else if (property.hasOwnProperty('value')) {\n                // handle constants\n                definedProperty.value = property.value;\n                definedProperty.writable = property.hasOwnProperty('writable') ? property.writable : true;\n            }\n\n            if (!definedProperty.hasOwnProperty('writable')) {\n                // handle setter and getter\n                var interceptors = struct.interceptors[property.propName] || {};\n                if (property.set) {\n                    var setStack = interceptors.set || [];\n                    definedProperty.set = accessorFactory(setStack, property.set);\n                }\n                if (property.get) {\n                    var getStack = interceptors.get || [];\n                    definedProperty.get = accessorFactory(getStack, property.get);\n                }\n            }\n\n            return Object.assign(property, {\n                property: definedProperty\n            });\n        }).reduce(function (previous, current) {\n            previous[current.propName] = current.property;\n            return previous;\n        }, {});\n    }\n    testing.createDefinedPropertiesHash = createDefinedPropertiesHash;\n\n    function createMethodsHash(struct) {\n        return Object.getOwnPropertyNames(struct.methods).map(function (methName) {\n            var stack = struct.wrappers[methName] || [];\n            var fn = struct.methods[methName];\n            return {\n                methName: methName,\n                fn: methodFactory(stack, fn)\n            };\n        }).reduce(function (previous, current) {\n            previous[current.methName] = current.fn;\n            return previous;\n        }, {});\n    }\n    testing.createMethodsHash = createMethodsHash;\n\n    /* BUILD */\n\n    var build = function build(struct) {\n        sanitizeStructure(struct);\n        setupFeatures(struct);\n\n        struct.definedProperties = createDefinedPropertiesHash(struct);\n        struct.attributes = createAttributesHash(struct);\n        struct.methods = createMethodsHash(struct);\n\n        Object.defineProperties(struct.prototype, struct.definedProperties);\n        Object.assign(struct.prototype, struct.methods);\n\n        return document.registerElement(struct.tagName, struct);\n    };\n    testing.build = build;\n\n    /* FEATURES */\n\n    var builtInFeatures = {};\n    testing.builtInFeatures = builtInFeatures;\n\n    builtInFeatures.delegate = emptyFn();\n    builtInFeatures.delegate.delegableAccessorInterceptor = function (property, next, el, value) {\n        next(value);\n        var target = el.querySelector(property.delegate.target);\n        /* istanbul ignore else  */\n        if (target) {\n            var targetPropName = property.delegate.property;\n            var targetAttName = property.delegate.attribute;\n            if (!targetPropName && !targetAttName) {\n                targetPropName = property.propName;\n                targetAttName = property.attName;\n            }\n            var isBoolean = property.attribute && !!property.attribute.boolean;\n            if (property.delegate.hasOwnProperty('boolean')) {\n                isBoolean = property.delegate.boolean;\n            }\n            if (targetAttName) {\n                applyAttributeValue(target, targetAttName, value, isBoolean);\n            } else {\n                target[targetPropName] = el[property.propName];\n            }\n        }\n    };\n    builtInFeatures.delegate.setup = function (struct, builder) {\n        // keep only properties configured for delegation\n        listValues(struct.properties).filter(function (property) {\n            return property.delegate;\n        }).forEach(function (property) {\n            // intercept the setter\n            var delegableAccessorInterceptor = builtInFeatures.delegate.delegableAccessorInterceptor;\n            builder.intercept(property.propName, delegableAccessorInterceptor.bind(builtInFeatures.delegate, property));\n        });\n    };\n\n    builtInFeatures.valueInitializer = emptyFn();\n    builtInFeatures.valueInitializer.createdCallbackWrapper = function (struct, next, el) {\n        next(arguments);\n        listValues(struct.properties).forEach(function (property) {\n            if (property.attName) {\n                if (el.hasAttribute(property.attName)) {\n                    el[property.propName] = property.attribute.boolean ? true : el.getAttribute(property.attName);\n                }\n                if (property.hasOwnProperty('value')) {\n                    applyAttributeValue(el, property.attName, property.value, property.attribute.boolean);\n                }\n            } else if (property.value && property.writable) {\n                el[property.propName] = property.value;\n            }\n        });\n    };\n    builtInFeatures.valueInitializer.attributeChangedCallbackWrapper = function (struct, next, el, attName, oldVal, newVal) {\n        var property = struct.attributes[attName];\n        if (property) {\n            var value = newVal;\n            if (property.attribute.boolean) {\n                value = typeof newVal === 'string' ? true : false;\n            }\n            el[property.propName] = value;\n        }\n        next(arguments);\n    };\n    builtInFeatures.valueInitializer.setup = function (struct, builder) {\n        var createdCallbackWrapper = builtInFeatures.valueInitializer.createdCallbackWrapper;\n        var attributeChangedCallbackWrapper = builtInFeatures.valueInitializer.attributeChangedCallbackWrapper;\n        builder.wrap('createdCallback', createdCallbackWrapper.bind(builtInFeatures.valueInitializer, struct));\n        builder.wrap('attributeChangedCallback', attributeChangedCallbackWrapper.bind(builtInFeatures.valueInitializer, struct));\n    };\n\n    /* BUILDER */\n\n    function baseStructFactory() {\n        return {\n            properties: {},\n            methods: {},\n            wrappers: [],\n            interceptors: [],\n            features: [{\n                fn: builtInFeatures.delegate,\n                level: -2\n            }, {\n                fn: builtInFeatures.valueInitializer,\n                level: -1\n            }]\n        };\n    }\n    testing.baseStructFactory = baseStructFactory;\n\n    function sanitizeProperty(property) {\n        if (property.attribute) {\n            property.attName = property.attribute.name || fromCamelCaseToHyphenCase(property.propName);\n        }\n        property.writable = property.hasOwnProperty('writable') ? property.writable : true;\n        return property;\n    }\n    testing.sanitizeProperty = sanitizeProperty;\n\n    var builder = function builder(tagName, params) {\n        var struct = params && params.struct ? params.struct : baseStructFactory();\n        struct.tagName = tagName;\n        var registered = params && params.hasOwnProperty('registered') ? params.registered : false;\n        var api = {};\n        // WRAPPER\n        api.wrap = function (methName, fn, level) {\n            if (!struct.wrappers[methName]) {\n                struct.wrappers[methName] = [];\n            }\n            fn.level = isNaN(level) ? 0 : level;\n            struct.wrappers[methName].push(fn);\n            return api;\n        };\n        api.intercept = function (propName, setFn, getFn, level) {\n            if (!struct.interceptors[propName]) {\n                struct.interceptors[propName] = {\n                    set: [],\n                    get: []\n                };\n            }\n            if (setFn) {\n                setFn.level = isNaN(level) ? 0 : level;\n                struct.interceptors[propName].set.push(setFn);\n            }\n            if (getFn) {\n                getFn.level = isNaN(level) ? 0 : level;\n                struct.interceptors[propName].get.push(getFn);\n            }\n            return api;\n        };\n        // INTEGRATION\n        api['extends'] = function (anExtend) {\n            struct['extends'] = anExtend;\n            return api;\n        };\n        api.prototype = function (aProto) {\n            struct.prototype = aProto;\n            return api;\n        };\n        // FELDS\n        api.properties = function (someProperties) {\n\n            var sanitizedProperties = Object.getOwnPropertyNames(someProperties || {}).map(function (propName) {\n                return Object.assign(someProperties[propName], {\n                    propName: propName\n                });\n            }).map(sanitizeProperty).reduce(function (previous, current) {\n                previous[current.propName] = current;\n                return previous;\n            }, {});\n\n            Object.assign(struct.properties, sanitizedProperties);\n\n            return api;\n        };\n        api.methods = function (someMethods) {\n            Object.assign(struct.methods, someMethods);\n            return api;\n        };\n        // FEATURES\n        api.feature = function (fn, options, level) {\n            struct.features.push({\n                fn: fn,\n                options: options,\n                level: isNaN(level) ? 0 : level\n            });\n            return api;\n        };\n        api.register = function () {\n            if (!registered) {\n                registered = true;\n                return build(struct);\n            }\n        };\n        api.get = function () {\n            return struct;\n        };\n        return api;\n    };\n    testing.builder = builder;\n\n    function factory(params) {\n        var api = {};\n        api.start = function (tagName) {\n            return builder(tagName, params);\n        };\n        return api;\n    }\n    factory._testing = testing;\n\n    return factory;\n}));\n"]}