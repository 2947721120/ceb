{"version":3,"file":"ceb.min.js","sources":["../src/ceb.js"],"names":["g","factory","exports","module","define","amd","ceb","this","emptyFn","listValues","o","Object","getOwnPropertyNames","map","propName","fromCamelCaseToHyphenCase","value","split","part","charAt","toLowerCase","slice","join","compareLevels","a","b","level","applyAttributeValue","el","attName","isBoolean","hasAttribute","setAttribute","removeAttribute","undefined","getAttribute","accessorFactory","wrappers","wrapped","stack","sort","reduce","previous","current","bind","apply","arguments","attributeAccessorSetFactory","setter","attValue","call","attributeAccessorGetFactory","getter","methodFactory","args","Array","prototype","length","sanitizeStructure","struct","create","HTMLElement","features","interceptors","listeners","properties","methods","assign","createdCallback","attachedCallback","detachedCallback","attributeChangedCallback","setupFeatures","builder","tagName","registered","forEach","feature","fn","setup","options","createAttributesHash","filter","property","createDefinedPropertiesHash","definedProperty","configurable","enumerable","attribute","set","get","hasOwnProperty","writable","setStack","getStack","createMethodsHash","methName","delegableSetAccessorInterceptor","next","target","querySelector","delegate","targetPropName","targetAttName","delegableGetAccessorInterceptor","result","eventListener","evt","baseStructFactory","builtInFeature","sanitizeProperty","name","params","api","build","definedProperties","attributes","defineProperties","document","registerElement","intercept","wrap","__eventHandlers","listener","callback","addEventListener","event","handler","removeEventListener","oldVal","newVal","isNaN","push","setFn","getFn","anExtend","aProto","someProperties","sanitizedProperties","someMethods","listen","queries","trim","query","parts","register"],"mappings":"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","sourcesContent":["(function (g, factory) {\n    /* globals module:0, define:0 */\n\n    'use strict';\n\n    /* istanbul ignore next */\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb', [], factory);\n    } else {\n        g.ceb = factory();\n    }\n\n}(this, function () {\n\n    'use strict';\n\n    /* TOOLS */\n\n    function emptyFn() {\n        return function () {};\n    }\n\n    function listValues(o) {\n        return Object.getOwnPropertyNames(o).map(function (propName) {\n            return o[propName];\n        });\n    }\n\n    // transform property notation to attribute notation\n    function fromCamelCaseToHyphenCase(value) {\n        return value.split(/(?=[A-Z])/).map(function (part) {\n            return part.charAt(0).toLowerCase() + part.slice(1);\n        }).join('-');\n    }\n\n    function compareLevels(a, b) {\n        return a.level - b.level;\n    }\n\n    function applyAttributeValue(el, attName, value, isBoolean) {\n        if (isBoolean) {\n            if (value && !el.hasAttribute(attName)) {\n                el.setAttribute(attName, '');\n            } else if (!value && el.hasAttribute(attName)) {\n                el.removeAttribute(attName);\n            }\n        } else {\n            if ((value === null || value === undefined) && el.hasAttribute(attName)) {\n                el.removeAttribute(attName);\n            } else if ((value !== null && value !== undefined) && el.getAttribute(attName) !== value) {\n                el.setAttribute(attName, value);\n            }\n        }\n    }\n\n    function accessorFactory(wrappers, wrapped) {\n        var stack = wrappers.sort(compareLevels);\n        return function accessor() {\n            var el = this;\n            return stack.reduce(function (previous, current) {\n                return current.bind(el, previous, el);\n            }, wrapped.bind(el, el)).apply(el, arguments);\n        };\n    }\n\n    function attributeAccessorSetFactory(attName, setter, isBoolean) {\n        return function attributeAccessorSet(el, value) {\n            var attValue = value;\n            if (setter) {\n                attValue = setter.call(el, el, value);\n            }\n            applyAttributeValue(el, attName, attValue, isBoolean);\n        };\n    }\n\n    function attributeAccessorGetFactory(attName, getter, isBoolean) {\n        return function attributeAccessorGet(el) {\n            var value = isBoolean ? el.hasAttribute(attName) : el.getAttribute(attName);\n            if (getter) {\n                value = getter.call(el, el, value);\n            }\n            return value;\n        };\n    }\n\n    function methodFactory(wrappers, wrapped) {\n        var stack = wrappers.sort(compareLevels);\n        return function () {\n            var el = this;\n            return stack.reduce(function (previous, current) {\n                return current.bind(el, function next(args) {\n                    return previous.apply(el, Array.prototype.slice.call(args).slice(2, args.length));\n                }, el);\n            }, wrapped.bind(el, el)).apply(el, arguments);\n        };\n    }\n\n    /* BUILD LIFE CYCLE */\n\n    function sanitizeStructure(struct) {\n        struct.prototype = struct.prototype || Object.create(HTMLElement.prototype);\n        struct.features = struct.features || [];\n        struct.interceptors = struct.interceptors || [];\n        struct.wrappers = struct.wrappers || [];\n        struct.listeners = struct.listeners || [];\n        struct.properties = struct.properties || {};\n        struct.methods = Object.assign({\n            createdCallback: emptyFn(),\n            attachedCallback: emptyFn(),\n            detachedCallback: emptyFn(),\n            attributeChangedCallback: emptyFn()\n        }, struct.methods);\n        return struct;\n    }\n\n    function setupFeatures(struct) {\n        var b = builder(struct.tagName, {\n            struct: struct,\n            registered: true\n        });\n        struct.features.sort(compareLevels).forEach(function (feature) {\n            if (feature.fn && feature.fn.setup) {\n                feature.fn.setup(struct, b, feature.options);\n            }\n        });\n    }\n\n    function createAttributesHash(struct) {\n        return listValues(struct.properties).filter(function (property) {\n            return property.attName;\n        }).reduce(function (previous, current) {\n            previous[current.attName] = current;\n            return previous;\n        }, {});\n    }\n\n    function createDefinedPropertiesHash(struct) {\n        return listValues(struct.properties).map(function (property) {\n            // default parameters\n            var definedProperty = {\n                configurable: false,\n                enumerable: true\n            };\n\n            if (property.attribute) {\n                // handle properties linked to an attribute\n                property.set = attributeAccessorSetFactory(property.attName, property.setter, !!property.attribute.boolean);\n                property.get = attributeAccessorGetFactory(property.attName, property.getter, !!property.attribute.boolean);\n            } else if (property.hasOwnProperty('value') && property.hasOwnProperty('writable') && !property.writable) {\n                // handle constants\n                definedProperty.value = property.value;\n                definedProperty.writable = false;\n            } else if (!property.set && !property.get) {\n                definedProperty.writable = true;\n            }\n\n            if (!definedProperty.hasOwnProperty('writable')) {\n                // handle setter and getter\n                var interceptors = struct.interceptors[property.propName] || {};\n                if (property.set) {\n                    var setStack = interceptors.set || [];\n                    definedProperty.set = accessorFactory(setStack, property.set);\n                }\n                if (property.get) {\n                    var getStack = interceptors.get || [];\n                    definedProperty.get = accessorFactory(getStack, property.get);\n                }\n            }\n\n            return Object.assign(property, {\n                property: definedProperty\n            });\n        }).reduce(function (previous, current) {\n            previous[current.propName] = current.property;\n            return previous;\n        }, {});\n    }\n\n    function createMethodsHash(struct) {\n        return Object.getOwnPropertyNames(struct.methods).map(function (methName) {\n            var stack = struct.wrappers[methName] || [];\n            var fn = struct.methods[methName];\n            return {\n                methName: methName,\n                fn: methodFactory(stack, fn)\n            };\n        }).reduce(function (previous, current) {\n            previous[current.methName] = current.fn;\n            return previous;\n        }, {});\n    }\n\n    /* BUILD */\n\n    var build = function build(struct) {\n        sanitizeStructure(struct);\n        setupFeatures(struct);\n\n        struct.definedProperties = createDefinedPropertiesHash(struct);\n        struct.attributes = createAttributesHash(struct);\n        struct.methods = createMethodsHash(struct);\n\n        Object.defineProperties(struct.prototype, struct.definedProperties);\n        Object.assign(struct.prototype, struct.methods);\n\n        return document.registerElement(struct.tagName, struct);\n    };\n\n    /* Built-in feature */\n\n    function delegableSetAccessorInterceptor(property, next, el, value) {\n        next(value);\n        var target = el.querySelector(property.delegate.target);\n        /* istanbul ignore else  */\n        if (target) {\n            var targetPropName = property.delegate.property;\n            var targetAttName = property.delegate.attribute;\n            if (!targetPropName && !targetAttName) {\n                targetPropName = property.propName;\n                targetAttName = property.attName;\n            }\n            var isBoolean = property.attribute && !!property.attribute.boolean;\n            if (property.delegate.hasOwnProperty('boolean')) {\n                isBoolean = property.delegate.boolean;\n            }\n            if (targetAttName) {\n                applyAttributeValue(target, targetAttName, value, isBoolean);\n            } else {\n                target[targetPropName] = value;\n            }\n        }\n    }\n\n    function delegableGetAccessorInterceptor(property, next, el, value) {\n        var result = next(value);\n        var target = el.querySelector(property.delegate.target);\n        /* istanbul ignore else  */\n        if (target) {\n            var targetPropName = property.delegate.property;\n            var targetAttName = property.delegate.attribute;\n            if (!targetPropName && !targetAttName) {\n                targetPropName = property.propName;\n                targetAttName = property.attName;\n            }\n            var isBoolean = property.attribute && !!property.attribute.boolean;\n            if (property.delegate.hasOwnProperty('boolean')) {\n                isBoolean = property.delegate.boolean;\n            }\n            if (targetAttName) {\n                result = isBoolean ? target.hasAttribute(targetAttName) : target.getAttribute(targetAttName);\n            } else {\n                result = target[targetPropName];\n            }\n        }\n        return result;\n    }\n\n    function eventListener(el, fn, evt) {\n        fn(el, evt);\n    }\n\n    var builtInFeature = emptyFn();\n    builtInFeature.setup = function (struct, builder) {\n        // keep only properties configured for delegation\n        listValues(struct.properties).filter(function (property) {\n            return property.delegate;\n        }).forEach(function (property) {\n            // intercept the setter\n            if (!property.attName) {\n                property.set = property.set || emptyFn();\n                property.get = property.get || emptyFn();\n            }\n            builder.intercept(\n                property.propName,\n                delegableSetAccessorInterceptor.bind(this, property),\n                delegableGetAccessorInterceptor.bind(this, property)\n            );\n        });\n        builder.wrap('createdCallback', function (next, el) {\n            // initialize properties values\n            listValues(struct.properties).forEach(function (property) {\n                if (property.attName) {\n                    if (el.hasAttribute(property.attName)) {\n                        el[property.propName] = property.attribute.boolean ? true : el.getAttribute(property.attName);\n                    } else if (property.hasOwnProperty('value')) {\n                        applyAttributeValue(el, property.attName, property.value, property.attribute.boolean);\n                    }\n                } else if (property.hasOwnProperty('value') && property.writable) {\n                    el[property.propName] = property.value;\n                }\n            });\n            next(arguments);\n        });\n        builder.wrap('attachedCallback', function (next, el) {\n            next(arguments);\n            // listen events\n            el.__eventHandlers = struct.listeners.map(function (listener) {\n                var target = listener.target ? el.querySelector(listener.target) : el;\n                var callback = eventListener.bind(el, el, listener.fn);\n                target.addEventListener(listener.event, callback, true);\n                return {\n                    event: listener.event,\n                    target: target,\n                    callback: callback\n                };\n            });\n        });\n        builder.wrap('detachedCallback', function (next, el) {\n            // release event handlers\n            el.__eventHandlers.forEach(function (handler) {\n                handler.target.removeEventListener(handler.event, handler.callback, true);\n            });\n            el.__eventHandlers = null;\n            next(arguments);\n        });\n        builder.wrap('attributeChangedCallback', function (next, el, attName, oldVal, newVal) {\n            // sync the attribute value with the property value\n            var property = struct.attributes[attName];\n            if (property) {\n                var value = newVal;\n                if (property.attribute.boolean) {\n                    value = typeof newVal === 'string' ? true : false;\n                }\n                el[property.propName] = value;\n            }\n            next(arguments);\n        });\n    };\n\n    /* BUILDER */\n\n    function baseStructFactory() {\n        return {\n            properties: {},\n            methods: {},\n            wrappers: [],\n            interceptors: [],\n            listeners: [],\n            features: [{\n                fn: builtInFeature\n            }]\n        };\n    }\n\n    function sanitizeProperty(property) {\n        if (property.attribute) {\n            property.attName = property.attribute.name || fromCamelCaseToHyphenCase(property.propName);\n        }\n        property.writable = property.hasOwnProperty('writable') ? property.writable : true;\n        return property;\n    }\n\n    var builder = function builder(tagName, params) {\n        var struct = params && params.struct ? sanitizeStructure(params.struct) : baseStructFactory();\n        struct.tagName = tagName;\n        var registered = params && params.hasOwnProperty('registered') ? params.registered : false;\n        var api = {};\n        // Wrappers and intercetpors\n        api.wrap = function (methName, fn, level) {\n            if (!struct.wrappers[methName]) {\n                struct.wrappers[methName] = [];\n            }\n            fn.level = isNaN(level) ? 0 : level;\n            struct.wrappers[methName].push(fn);\n            return api;\n        };\n        api.intercept = function (propName, setFn, getFn, level) {\n            if (!struct.interceptors[propName]) {\n                struct.interceptors[propName] = {\n                    set: [],\n                    get: []\n                };\n            }\n            if (setFn) {\n                setFn.level = isNaN(level) ? 0 : level;\n                struct.interceptors[propName].set.push(setFn);\n            }\n            if (getFn) {\n                getFn.level = isNaN(level) ? 0 : level;\n                struct.interceptors[propName].get.push(getFn);\n            }\n            return api;\n        };\n        // INTEGRATION\n        api['extends'] = function (anExtend) {\n            struct['extends'] = anExtend;\n            return api;\n        };\n        api.prototype = function (aProto) {\n            struct.prototype = aProto;\n            return api;\n        };\n        // FELDS\n        api.properties = function (someProperties) {\n\n            var sanitizedProperties = Object.getOwnPropertyNames(someProperties).map(function (propName) {\n                return Object.assign(someProperties[propName], {\n                    propName: propName\n                });\n            }).map(sanitizeProperty).reduce(function (previous, current) {\n                previous[current.propName] = current;\n                return previous;\n            }, {});\n\n            Object.assign(struct.properties, sanitizedProperties);\n\n            return api;\n        };\n        api.methods = function (someMethods) {\n            Object.assign(struct.methods, someMethods);\n            return api;\n        };\n        // Events\n        api.listen = function (queries, fn) {\n            queries.trim().split(',').map(function (query) {\n                var parts = query.trim().split(' ');\n                return {\n                    event: parts[0].trim(),\n                    target: (parts[1] || '').trim(),\n                    fn: fn\n                };\n            }).forEach(function (listener) {\n                struct.listeners.push(listener);\n            });\n            return api;\n        };\n        // FEATURES\n        api.feature = function (fn, options, level) {\n            struct.features.push({\n                fn: fn,\n                options: options,\n                level: isNaN(level) ? 0 : level\n            });\n            return api;\n        };\n        api.register = function () {\n            if (!registered) {\n                registered = true;\n                return build(struct);\n            }\n        };\n        api.get = function () {\n            return struct;\n        };\n        return api;\n    };\n\n    function factory(params) {\n        var api = {};\n        api.name = function (tagName) {\n            return builder(tagName, params);\n        };\n        return api;\n    }\n\n    return factory;\n}));\n"]}