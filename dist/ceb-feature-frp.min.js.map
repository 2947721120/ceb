{"version":3,"file":"ceb-feature-frp.min.js","sources":["../src/ceb-feature-frp.js"],"names":["g","factory","exports","module","require","define","amd","cebFeatureFrp","ceb","this","feature","el","__cebFrpScope","defaultPropertyObserverFactory","window","Rx","Subject","defaultPropertyObservableInterceptor","next","propName","value","onNext","defaultDisposeObserver","observer","dispose","setup","struct","builder","options","observerProperties","propertyObserverFactory","propertyObservableInterceptor","disposeObserver","Object","keys","properties","map","property","filter","entry","observable","forEach","valueFactory","intercept","wrap","arguments","observers","observerFactory","undefined"],"mappings":";;;;;;;;CAuCC,SAAUA,EAAGC,GACV,YAGuB,iBAAZC,SACPC,OAAOD,QAAUD,EAAQG,QAAQ,QACR,kBAAXC,SAAyBA,OAAOC,IAC9CD,OAAO,wBAAyB,OAAQJ,GAExCD,EAAEO,cAAgBN,EAAQD,EAAEQ,MAGlCC,KAAM,WACJ,YAKA,SAASC,GAAQC,GAIb,MAHKA,GAAGC,gBACJD,EAAGC,kBAEAD,EAAGC,cAgGd,MAzFAF,GAAQG,+BAAiC,WACrC,MAAO,IAAIC,QAAOC,GAAGC,SAQzBN,EAAQO,qCAAuC,SAA8CC,EAAMP,EAAIQ,EAAUC,GAC7GF,EAAKE,GACLT,EAAGQ,EAAW,YAAYE,OAAOD,IAKrCV,EAAQY,uBAAyB,SAAgCC,GAC7DA,EAASC,WAKbd,EAAQe,MAAQ,SAAUC,EAAQC,EAASC,GACvC,GAAIC,MAGAC,EAA0BF,EAAQE,yBAA2BpB,EAAQG,+BACrEkB,EAAgCH,EAAQG,+BAAiCrB,EAAQO,qCACjFe,EAAkBJ,EAAQI,iBAAmBtB,EAAQY,sBAGzDW,QAAOC,KAAKR,EAAOS,YAAYC,IAAI,SAAUjB,GACzC,OACIA,SAAUA,EACVkB,SAAUX,EAAOS,WAAWhB,MAEjCmB,OAAO,SAAUC,GAChB,MAAOA,GAAMF,SAASG,aACvBC,QAAQ,SAAUF,GAEjBV,EAAmBU,EAAMpB,SAAW,aAChCuB,aAAcZ,GAGlBH,EAAQgB,UAAUJ,EAAMpB,SAAUY,KAItCJ,EAAQQ,WAAWN,GAEnBF,EAAQiB,KAAK,kBAAmB,SAAU1B,EAAMP,GAC5CO,EAAK2B,WAEAnC,EAAQC,GAAImC,YACbpC,EAAQC,GAAImC,WAAalB,EAAQkB,eAAiBV,IAAI,SAAUW,GAC5D,MAAOA,GAAgBpC,QAKnCgB,EAAQiB,KAAK,mBAAoB,SAAU1B,EAAMP,GAE7CsB,OAAOC,KAAKL,GAAoBY,QAAQ,SAAUtB,GACzCR,EAAGQ,KACJR,EAAGQ,GAAYW,EAAwBnB,MAI1CD,EAAQC,GAAImC,YACbpC,EAAQC,GAAImC,WAAalB,EAAQkB,eAAiBV,IAAI,SAAUW,GAC5D,MAAOA,GAAgBpC,MAG/BO,EAAK2B,aAGTlB,EAAQiB,KAAK,mBAAoB,SAAU1B,EAAMP,GAC7CO,EAAK2B,WAELZ,OAAOC,KAAKL,GAAoBY,QAAQ,SAAUtB,GAC9Ca,EAAgBrB,EAAGQ,IACnBR,EAAGQ,GAAY6B,SAGnBtC,EAAQC,GAAImC,UAAUL,QAAQT,GAC9BtB,EAAQC,GAAImC,UAAY,QAIzBpC","sourcesContent":["// # ceb-feature-frp.js\n//\n// **NOT YET RELEASED**\n//\n// This feature gets Functional Reactive Programming to custom elements.\n// Presently, properties can be observed and observers can be created from scratch.\n//\n// ## Integration\n//\n// Due too the number of good libraries implementing the FRP paradigm\n// and because Custom Elements Builder is just a builder,\n// this feature is not locked to an external dependencies.\n//\n// So, some functions should be overridden to handle the targetted FRP librairy.\n// By default their implementation is locked to `window.Rx`.\n//\n// The functions can be overridden from the function feature:\n// - cebFeatureFrp.defaultPropertyObserverFactory\n// - cebFeatureFrp.defaultPropertyObservableInterceptor\n// - cebFeatureFrp.defaultDisposeObserver\n//\n// Or from the feature's options:\n// - options.propertyObserverFactory\n// - options.propertyObservableInterceptor\n// - options.disposeObserver\n//\n// ## Observed properties\n//\n// The observers of observed properties can be get from `myPropObserver`.\n//\n// To enable it, the property's structure must have the boolean **observable** to true.\n//\n// ## Observers\n//\n// Factory functions can be given as options in order to create observers from the current elements.\n//\n//     options.observer = [observerFactory]\n//\n// Where observerFactory is a function having the element as arguement.\n(function (g, factory) {\n    'use strict';\n\n    /* istanbul ignore next */\n    if (typeof exports === 'object') {\n        module.exports = factory(require('ceb'));\n    } else if (typeof define === 'function' && define.amd) {\n        define('ceb-feature-template', ['ceb'], factory);\n    } else {\n        g.cebFeatureFrp = factory(g.ceb);\n    }\n\n}(this, function (ceb) {\n    'use strict';\n\n    // ## feature function\n\n    // The FRP feature's function returns nothing for public API.\n    function feature(el) {\n        if (!el.__cebFrpScope) {\n            el.__cebFrpScope = {};\n        }\n        return el.__cebFrpScope;\n    }\n\n    // ## Default functions\n\n    // This function must returns the instance to the property observer.\n    // > @param el (HTMLElement) the current element\n    feature.defaultPropertyObserverFactory = function defaultPropertyObserverFactory() {\n        return new window.Rx.Subject();\n    };\n\n    // When the observed property is set, the value must be pushed into the stream.\n    // > @param next (function) will call the next stacked callback\n    // > @param el (HTMLElement) the current element\n    // > @param propName (string) the name of the observed property\n    // > @param value (*) the value of the previous stacked callback\n    feature.defaultPropertyObservableInterceptor = function defaultPropertyObservableInterceptor(next, el, propName, value) {\n        next(value);\n        el[propName + 'Observer'].onNext(value);\n    };\n\n    // This function must clear the observer instance given as argument.\n    // > @param observer (object) the observer to kick\n    feature.defaultDisposeObserver = function defaultDisposeObserver(observer) {\n        observer.dispose();\n    };\n\n    // ## Setup\n\n    feature.setup = function (struct, builder, options) {\n        var observerProperties = {};\n\n        // Resolve the locked functions.\n        var propertyObserverFactory = options.propertyObserverFactory || feature.defaultPropertyObserverFactory;\n        var propertyObservableInterceptor = options.propertyObservableInterceptor || feature.defaultPropertyObservableInterceptor;\n        var disposeObserver = options.disposeObserver || feature.defaultDisposeObserver;\n\n        // Iterate over the structure's properties in order to detect the observable properties.\n        Object.keys(struct.properties).map(function (propName) {\n            return {\n                propName: propName,\n                property: struct.properties[propName]\n            };\n        }).filter(function (entry) {\n            return entry.property.observable;\n        }).forEach(function (entry) {\n            // Create the observer property of the observed property.\n            observerProperties[entry.propName + 'Observer'] = {\n                valueFactory: propertyObserverFactory\n            };\n            // Register the interceptor which will sync the observer with the property's value.\n            builder.intercept(entry.propName, propertyObservableInterceptor);\n        });\n\n        // Add the new properties to the structure.\n        builder.properties(observerProperties);\n\n        builder.wrap('createdCallback', function (next, el) {\n            next(arguments);\n            // When the element is created the observers must created.\n            if (!feature(el).observers) {\n                feature(el).observers = (options.observers || []).map(function (observerFactory) {\n                    return observerFactory(el);\n                });\n            }\n        });\n\n        builder.wrap('attachedCallback', function (next, el) {\n            // When the element is attached the observers of properties must be available ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                if (!el[propName]) {\n                    el[propName] = propertyObserverFactory(el);\n                }\n            });\n            // ... and the others observers too.\n            if (!feature(el).observers) {\n                feature(el).observers = (options.observers || []).map(function (observerFactory) {\n                    return observerFactory(el);\n                });\n            }\n            next(arguments);\n        });\n\n        builder.wrap('detachedCallback', function (next, el) {\n            next(arguments);\n            // When the element is detached the observers of properties must be disposed ...\n            Object.keys(observerProperties).forEach(function (propName) {\n                disposeObserver(el[propName]);\n                el[propName] = undefined;\n            });\n            // ... and the others observers too.\n            feature(el).observers.forEach(disposeObserver);\n            feature(el).observers = null;\n        });\n    };\n\n    return feature;\n}));\n"]}