{"version":3,"sources":["incremental-dom-cjs.js","src/notifications.js","src/tree_walker.js","src/context.js","src/util.js","src/node_data.js","src/symbols.js","src/attributes.js","src/namespace.js","src/nodes.js","src/alignment.js","src/traversal.js","src/patch.js","src/virtual_elements.js"],"names":[],"mappings":"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","file":"incremental-dom-cjs.js","sourcesContent":["\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nexports.notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Similar to the built-in Treewalker class, but simplified and allows direct\n * access to modify the currentNode property.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     walker should start traversing.\n * @constructor\n */\nfunction TreeWalker(node) {\n  /**\n   * Keeps track of the current parent node. This is necessary as the traversal\n   * methods may traverse past the last child and we still need a way to get\n   * back to the parent.\n   * @const @private {!Array<!Node>}\n   */\n  this.stack_ = [];\n\n  /**\n   * @const {!Element|!DocumentFragment}\n   */\n  this.root = node;\n\n  /**\n   * @type {?Node}\n   */\n  this.currentNode = node;\n}\n\n\n/**\n * @return {!Node} The current parent of the current location in the subtree.\n */\nTreeWalker.prototype.getCurrentParent = function() {\n  return this.stack_[this.stack_.length - 1];\n};\n\n\n/**\n * Changes the current location the firstChild of the current location.\n */\nTreeWalker.prototype.firstChild = function() {\n  this.stack_.push(this.currentNode);\n  this.currentNode = this.currentNode.firstChild;\n};\n\n\n/**\n * Changes the current location the nextSibling of the current location.\n */\nTreeWalker.prototype.nextSibling = function() {\n  this.currentNode = this.currentNode.nextSibling;\n};\n\n\n/**\n * Changes the current location the parentNode of the current location.\n */\nTreeWalker.prototype.parentNode = function() {\n  this.currentNode = this.stack_.pop();\n};\n\n/**\n * Keeps track of the state of a patch.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     is for.\n * @param {?Context} prevContext The previous context.\n * @constructor\n */\nfunction Context(node, prevContext) {\n  /**\n   * @const {TreeWalker}\n   */\n  this.walker = new TreeWalker(node);\n\n  /**\n   * @const {Document}\n   */\n  this.doc = node.ownerDocument;\n\n  /**\n   * Keeps track of what namespace to create new Elements in.\n   * @private\n   * @const {!Array<(string|undefined)>}\n   */\n  this.nsStack_ = [undefined];\n\n  /**\n   * @const {?Context}\n   */\n  this.prevContext = prevContext;\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = exports.notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = exports.notifications.nodesDeleted && [];\n}\n\n\n/**\n * @return {(string|undefined)} The current namespace to create Elements in.\n */\nContext.prototype.getCurrentNamespace = function() {\n  return this.nsStack_[this.nsStack_.length - 1];\n};\n\n\n/**\n * @param {string=} namespace The namespace to enter.\n */\nContext.prototype.enterNamespace = function(namespace) {\n  this.nsStack_.push(namespace);\n};\n\n\n/**\n * Exits the current namespace\n */\nContext.prototype.exitNamespace = function() {\n  this.nsStack_.pop();\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function(node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function(node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function() {\n  if (this.created && this.created.length > 0) {\n    exports.notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    exports.notifications.nodesDeleted(this.deleted);\n  }\n};\n\n\n/**\n * The current context.\n * @type {?Context}\n */\nvar context;\n\n\n/**\n * Enters a new patch context.\n * @param {!Element|!DocumentFragment} node\n */\nvar enterContext = function(node) {\n  context = new Context(node, context);\n};\n\n\n/**\n * Restores the previous patch context.\n */\nvar restoreContext = function() {\n  context = context.prevContext;\n};\n\n\n/**\n * Gets the current patch context.\n * @return {?Context}\n */\nvar getContext = function() {\n  return context;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function() {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The last child to have been visited within the current pass.\n   * @type {?Node}\n   */\n  this.lastVisitedChild = null;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function(node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function(node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexports.symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nexports.applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nexports.applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {string|Object<string,string>} style The style to set. Either a\n *     string of css or an object containing property-value pairs.\n */\nvar applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n\n    for (var prop in style) {\n      if (has(style, prop)) {\n        elStyle[prop] = style[prop];\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function(el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    exports.applyProp(el, name, value);\n  } else {\n    exports.applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function(el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = exports.attributes[name] || exports.attributes[exports.symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nexports.attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nexports.attributes[exports.symbols.default] = applyAttributeTyped;\n\nexports.attributes[exports.symbols.placeholder] = function() {};\n\nexports.attributes['style'] = applyStyle;\n\nvar SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Enters a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar enterTag = function(tag) {\n  if (tag === 'svg') {\n    getContext().enterNamespace(SVG_NS);\n  } else if (tag === 'foreignObject') {\n    getContext().enterNamespace(undefined);\n  }\n};\n\n\n/**\n * Exits a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar exitTag = function(tag) {\n  if (tag === 'svg' || tag === 'foreignObject') {\n    getContext().exitNamespace();\n  }\n};\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @return {(string|undefined)} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function(tag) {\n  if (tag === 'svg') {\n    return SVG_NS;\n  }\n\n  return getContext().getCurrentNamespace();\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function(doc, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/(statics[i]), statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n\n/**\n * Creates a Node, either a Text or an Element depending on the node name\n * provided.\n * @param {Document} doc The document with which to create the Node.\n * @param {string} nodeName The tag if creating an element or #text to create\n *     a Text.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics The static data to initialize the Node\n *     with. For an Element, an array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Node}\n */\nvar createNode = function(doc, nodeName, key, statics) {\n  if (nodeName === '#text') {\n    return doc.createTextNode('');\n  }\n\n  return createElement(doc, nodeName, key, statics);\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {!Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function(el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {!Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function(el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {!Node} parent\n * @param {?string=} key\n * @return {?Element} The child corresponding to the key.\n */\nvar getChild = function(parent, key) {\n  return /** @type {?Element} */(key && getKeyMap(parent)[key]);\n};\n\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {!Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n  * Makes sure that keyed Element matches the tag name provided.\n  * @param {!Element} node The node that is being matched.\n  * @param {string=} tag The tag name of the Element.\n  * @param {?string=} key The key of the Element.\n  */\n  var assertKeyedTagMatches = function(node, tag, key) {\n    var nodeName = getData(node).nodeName;\n    if (nodeName !== tag) {\n      throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\n          tag + ', not a ' + nodeName + '.');\n    }\n  };\n}\n\n\n/**\n * Checks whether or not a given node matches the specified nodeName and key.\n *\n * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function(node, nodeName, key) {\n  var data = getData(node);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return key == data.key && nodeName === data.nodeName;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n * @return {!Node} The matching node.\n */\nvar alignWithDOM = function(nodeName, key, statics) {\n  var context = getContext();\n  var walker = context.walker;\n  var currentNode = walker.currentNode;\n  var parent = walker.getCurrentParent();\n  var matchingNode;\n\n  // Check to see if we have a node to reuse\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    matchingNode = currentNode;\n  } else {\n    var existingNode = getChild(parent, key);\n\n    // Check to see if the node has moved within the parent or if a new one\n    // should be created\n    if (existingNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        assertKeyedTagMatches(existingNode, nodeName, key);\n      }\n\n      matchingNode = existingNode;\n    } else {\n      matchingNode = createNode(context.doc, nodeName, key, statics);\n\n      if (key) {\n        registerChild(parent, key, matchingNode);\n      }\n\n      context.markCreated(matchingNode);\n    }\n\n    // If the node has a key, remove it from the DOM to prevent a large number\n    // of re-orders in the case that it moved far or was completely removed.\n    // Since we hold on to a reference through the keyMap, we can always add it\n    // back.\n    if (currentNode && getData(currentNode).key) {\n      parent.replaceChild(matchingNode, currentNode);\n      getData(parent).keyMapValid = false;\n    } else {\n      parent.insertBefore(matchingNode, currentNode);\n    }\n\n    walker.currentNode = matchingNode;\n  }\n\n  return matchingNode;\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n * @param {Node} node\n */\nvar clearUnvisitedDOM = function(node) {\n  var context = getContext();\n  var walker = context.walker;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var lastVisitedChild = data.lastVisitedChild;\n  var child = node.lastChild;\n  var key;\n\n  data.lastVisitedChild = null;\n\n  if (child === lastVisitedChild && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[exports.symbols.placeholder] && walker.currentNode !== walker.root) {\n    return;\n  }\n\n  while (child !== lastVisitedChild) {\n    node.removeChild(child);\n    context.markDeleted(/** @type {!Node}*/(child));\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  for (key in keyMap) {\n    child = keyMap[key];\n    if (!child.parentNode) {\n      context.markDeleted(child);\n      delete keyMap[key];\n    }\n  }\n\n  data.keyMapValid = true;\n};\n\n/**\n * Enters an Element, setting the current namespace for nested elements.\n * @param {Node} node\n */\nvar enterNode = function(node) {\n  var data = getData(node);\n  enterTag(data.nodeName);\n};\n\n\n/**\n * Exits an Element, unwinding the current namespace to the previous value.\n * @param {Node} node\n */\nvar exitNode = function(node) {\n  var data = getData(node);\n  exitTag(data.nodeName);\n};\n\n\n/**\n * Marks node's parent as having visited node.\n * @param {Node} node\n */\nvar markVisited = function(node) {\n  var context = getContext();\n  var walker = context.walker;\n  var parent = walker.getCurrentParent();\n  var data = getData(parent);\n  data.lastVisitedChild = node;\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nvar firstChild = function() {\n  var context = getContext();\n  var walker = context.walker;\n  enterNode(walker.currentNode);\n  walker.firstChild();\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextSibling = function() {\n  var context = getContext();\n  var walker = context.walker;\n  markVisited(walker.currentNode);\n  walker.nextSibling();\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar parentNode = function() {\n  var context = getContext();\n  var walker = context.walker;\n  walker.parentNode();\n  exitNode(walker.currentNode);\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  var assertNoUnclosedTags = function(root) {\n    var openElement = getContext().walker.getCurrentParent();\n    if (!openElement) {\n      return;\n    }\n\n    var openTags = [];\n    while (openElement && openElement !== root) {\n      openTags.push(openElement.nodeName.toLowerCase());\n      openElement = openElement.parentNode;\n    }\n\n    throw new Error('One or more tags were not closed:\\n' +\n        openTags.join('\\n'));\n  };\n}\n\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nexports.patch = function(node, fn, data) {\n  enterContext(node);\n\n  firstChild();\n  fn(data);\n  parentNode();\n  clearUnvisitedDOM(node);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(node);\n  }\n\n  getContext().notifyChanges();\n  restoreContext();\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n   * Keeps track whether or not we are in an attributes declaration (after\n   * elementOpenStart, but before elementOpenEnd).\n   * @type {boolean}\n   */\n  var inAttributes = false;\n\n\n  /** Makes sure that the caller is not where attributes are expected. */\n  var assertNotInAttributes = function() {\n    if (inAttributes) {\n      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' +\n          'they must follow a call to elementOpenStart.');\n    }\n  };\n\n\n  /** Makes sure that the caller is where attributes are expected. */\n  var assertInAttributes = function() {\n    if (!inAttributes) {\n      throw new Error('Was expecting a call to attr or elementOpenEnd. ' +\n          'elementOpenStart must be followed by zero or more calls to attr, ' +\n          'then one call to elementOpenEnd.');\n    }\n  };\n\n\n  /**\n   * Makes sure that placeholders have a key specified. Otherwise, conditional\n   * placeholders and conditional elements next to placeholders will cause\n   * placeholder elements to be re-used as non-placeholders and vice versa.\n   * @param {string} key\n   */\n  var assertPlaceholderKeySpecified = function(key) {\n    if (!key) {\n      throw new Error('Placeholder elements must have a key specified.');\n    }\n  };\n\n\n  /**\n   * Makes sure that tags are correctly nested.\n   * @param {string} tag\n   */\n  var assertCloseMatchesOpenTag = function(tag) {\n    var context = getContext();\n    var walker = context.walker;\n    var closingNode = walker.getCurrentParent();\n    var data = getData(closingNode);\n\n    if (tag !== data.nodeName) {\n      throw new Error('Received a call to close ' + tag + ' but ' +\n            data.nodeName + ' was open.');\n    }\n  };\n\n\n  /** Updates the state to being in an attribute declaration. */\n  var setInAttributes = function() {\n    inAttributes = true;\n  };\n\n\n  /** Updates the state to not being in an attribute declaration. */\n  var setNotInAttributes = function() {\n    inAttributes = false;\n  };\n}\n\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpen = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Element}*/(alignWithDOM(tag, key, statics));\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    var attr, newAttrs = data.newAttrs;\n\n    for (attr in newAttrs) {\n      newAttrs[attr] = undefined;\n    }\n\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n    }\n  }\n\n  firstChild();\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nexports.elementOpenStart = function(tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    setInAttributes();\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nexports.attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nexports.elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n    setNotInAttributes();\n  }\n\n  var node = exports.elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nexports.elementClose = function(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    assertCloseMatchesOpenTag(tag);\n  }\n\n  parentNode();\n\n  var node = /** @type {!Element} */(getContext().walker.currentNode);\n\n  clearUnvisitedDOM(node);\n\n  nextSibling();\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementVoid = function(tag, key, statics, var_args) {\n  var node = exports.elementOpen.apply(null, arguments);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nexports.elementPlaceholder = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  var node = exports.elementOpen.apply(null, arguments);\n  updateAttribute(node, exports.symbols.placeholder, true);\n  exports.elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nexports.text = function(value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Text}*/(alignWithDOM('#text', null));\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  nextSibling();\n  return node;\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\nexport {\n  notifications\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Similar to the built-in Treewalker class, but simplified and allows direct\n * access to modify the currentNode property.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     walker should start traversing.\n * @constructor\n */\nfunction TreeWalker(node) {\n  /**\n   * Keeps track of the current parent node. This is necessary as the traversal\n   * methods may traverse past the last child and we still need a way to get\n   * back to the parent.\n   * @const @private {!Array<!Node>}\n   */\n  this.stack_ = [];\n\n  /**\n   * @const {!Element|!DocumentFragment}\n   */\n  this.root = node;\n\n  /**\n   * @type {?Node}\n   */\n  this.currentNode = node;\n}\n\n\n/**\n * @return {!Node} The current parent of the current location in the subtree.\n */\nTreeWalker.prototype.getCurrentParent = function() {\n  return this.stack_[this.stack_.length - 1];\n};\n\n\n/**\n * Changes the current location the firstChild of the current location.\n */\nTreeWalker.prototype.firstChild = function() {\n  this.stack_.push(this.currentNode);\n  this.currentNode = this.currentNode.firstChild;\n};\n\n\n/**\n * Changes the current location the nextSibling of the current location.\n */\nTreeWalker.prototype.nextSibling = function() {\n  this.currentNode = this.currentNode.nextSibling;\n};\n\n\n/**\n * Changes the current location the parentNode of the current location.\n */\nTreeWalker.prototype.parentNode = function() {\n  this.currentNode = this.stack_.pop();\n};\n\n\n/** */\nexport {\n  TreeWalker\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TreeWalker } from './tree_walker';\nimport { notifications } from './notifications';\n\n\n/**\n * Keeps track of the state of a patch.\n * @param {!Element|!DocumentFragment} node The root Node of the subtree the\n *     is for.\n * @param {?Context} prevContext The previous context.\n * @constructor\n */\nfunction Context(node, prevContext) {\n  /**\n   * @const {TreeWalker}\n   */\n  this.walker = new TreeWalker(node);\n\n  /**\n   * @const {Document}\n   */\n  this.doc = node.ownerDocument;\n\n  /**\n   * Keeps track of what namespace to create new Elements in.\n   * @private\n   * @const {!Array<(string|undefined)>}\n   */\n  this.nsStack_ = [undefined];\n\n  /**\n   * @const {?Context}\n   */\n  this.prevContext = prevContext;\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n\n/**\n * @return {(string|undefined)} The current namespace to create Elements in.\n */\nContext.prototype.getCurrentNamespace = function() {\n  return this.nsStack_[this.nsStack_.length - 1];\n};\n\n\n/**\n * @param {string=} namespace The namespace to enter.\n */\nContext.prototype.enterNamespace = function(namespace) {\n  this.nsStack_.push(namespace);\n};\n\n\n/**\n * Exits the current namespace\n */\nContext.prototype.exitNamespace = function() {\n  this.nsStack_.pop();\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function(node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function(node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function() {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n\n/**\n * The current context.\n * @type {?Context}\n */\nvar context;\n\n\n/**\n * Enters a new patch context.\n * @param {!Element|!DocumentFragment} node\n */\nvar enterContext = function(node) {\n  context = new Context(node, context);\n};\n\n\n/**\n * Restores the previous patch context.\n */\nvar restoreContext = function() {\n  context = context.prevContext;\n};\n\n\n/**\n * Gets the current patch context.\n * @return {?Context}\n */\nvar getContext = function() {\n  return context;\n};\n\n\n/** */\nexport {\n  enterContext,\n  restoreContext,\n  getContext\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function() {\n  return create(null);\n};\n\n\n/** */\nexport {\n  createMap,\n  has\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createMap } from './util';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The last child to have been visited within the current pass.\n   * @type {?Node}\n   */\n  this.lastVisitedChild = null;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function(node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function(node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n\n/** */\nexport {\n  getData,\n  initData\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/** */\nexport {\n  symbols\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  createMap,\n  has\n} from './util';\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {string|Object<string,string>} style The style to set. Either a\n *     string of css or an object containing property-value pairs.\n */\nvar applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n\n    for (var prop in style) {\n      if (has(style, prop)) {\n        elStyle[prop] = style[prop];\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function(el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function(el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function() {};\n\nattributes['style'] = applyStyle;\n\n\n/** */\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getContext } from './context';\n\nvar SVG_NS = 'http://www.w3.org/2000/svg';\n\n/**\n * Enters a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar enterTag = function(tag) {\n  if (tag === 'svg') {\n    getContext().enterNamespace(SVG_NS);\n  } else if (tag === 'foreignObject') {\n    getContext().enterNamespace(undefined);\n  }\n};\n\n\n/**\n * Exits a tag, checking to see if it is a namespace boundary, and if so,\n * updates the current namespace.\n * @param {string} tag The tag to enter.\n */\nvar exitTag = function(tag) {\n  if (tag === 'svg' || tag === 'foreignObject') {\n    getContext().exitNamespace();\n  }\n};\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @return {(string|undefined)} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function(tag) {\n  if (tag === 'svg') {\n    return SVG_NS;\n  }\n\n  return getContext().getCurrentNamespace();\n};\n\n\n/** */\nexport {\n  enterTag,\n  exitTag,\n  getNamespaceForTag\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { updateAttribute } from './attributes';\nimport {\n    getData,\n    initData\n} from './node_data';\nimport { getNamespaceForTag } from './namespace';\nimport { createMap } from './util';\n\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function(doc, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag);\n  var el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/(statics[i]), statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n\n/**\n * Creates a Node, either a Text or an Element depending on the node name\n * provided.\n * @param {Document} doc The document with which to create the Node.\n * @param {string} nodeName The tag if creating an element or #text to create\n *     a Text.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics The static data to initialize the Node\n *     with. For an Element, an array of attribute name/value pairs of\n *     the static attributes for the Element.\n * @return {!Node}\n */\nvar createNode = function(doc, nodeName, key, statics) {\n  if (nodeName === '#text') {\n    return doc.createTextNode('');\n  }\n\n  return createElement(doc, nodeName, key, statics);\n};\n\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {!Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function(el) {\n  var map = createMap();\n  var children = el.children;\n  var count = children.length;\n\n  for (var i = 0; i < count; i += 1) {\n    var child = children[i];\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n  }\n\n  return map;\n};\n\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {!Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function(el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {!Node} parent\n * @param {?string=} key\n * @return {?Element} The child corresponding to the key.\n */\nvar getChild = function(parent, key) {\n  return /** @type {?Element} */(key && getKeyMap(parent)[key]);\n};\n\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {!Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function(parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n\n/** */\nexport {\n  createNode,\n  getChild,\n  registerChild\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n    createNode,\n    getChild,\n    registerChild\n} from './nodes';\nimport { getData } from './node_data';\nimport { getContext } from './context';\nimport { symbols } from './symbols';\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n  * Makes sure that keyed Element matches the tag name provided.\n  * @param {!Element} node The node that is being matched.\n  * @param {string=} tag The tag name of the Element.\n  * @param {?string=} key The key of the Element.\n  */\n  var assertKeyedTagMatches = function(node, tag, key) {\n    var nodeName = getData(node).nodeName;\n    if (nodeName !== tag) {\n      throw new Error('Was expecting node with key \"' + key + '\" to be a ' +\n          tag + ', not a ' + nodeName + '.');\n    }\n  };\n}\n\n\n/**\n * Checks whether or not a given node matches the specified nodeName and key.\n *\n * @param {!Node} node An HTML node, typically an HTMLElement or Text.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function(node, nodeName, key) {\n  var data = getData(node);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return key == data.key && nodeName === data.nodeName;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n * @return {!Node} The matching node.\n */\nvar alignWithDOM = function(nodeName, key, statics) {\n  var context = getContext();\n  var walker = context.walker;\n  var currentNode = walker.currentNode;\n  var parent = walker.getCurrentParent();\n  var matchingNode;\n\n  // Check to see if we have a node to reuse\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    matchingNode = currentNode;\n  } else {\n    var existingNode = getChild(parent, key);\n\n    // Check to see if the node has moved within the parent or if a new one\n    // should be created\n    if (existingNode) {\n      if (process.env.NODE_ENV !== 'production') {\n        assertKeyedTagMatches(existingNode, nodeName, key);\n      }\n\n      matchingNode = existingNode;\n    } else {\n      matchingNode = createNode(context.doc, nodeName, key, statics);\n\n      if (key) {\n        registerChild(parent, key, matchingNode);\n      }\n\n      context.markCreated(matchingNode);\n    }\n\n    // If the node has a key, remove it from the DOM to prevent a large number\n    // of re-orders in the case that it moved far or was completely removed.\n    // Since we hold on to a reference through the keyMap, we can always add it\n    // back.\n    if (currentNode && getData(currentNode).key) {\n      parent.replaceChild(matchingNode, currentNode);\n      getData(parent).keyMapValid = false;\n    } else {\n      parent.insertBefore(matchingNode, currentNode);\n    }\n\n    walker.currentNode = matchingNode;\n  }\n\n  return matchingNode;\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n * @param {Node} node\n */\nvar clearUnvisitedDOM = function(node) {\n  var context = getContext();\n  var walker = context.walker;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var lastVisitedChild = data.lastVisitedChild;\n  var child = node.lastChild;\n  var key;\n\n  data.lastVisitedChild = null;\n\n  if (child === lastVisitedChild && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && walker.currentNode !== walker.root) {\n    return;\n  }\n\n  while (child !== lastVisitedChild) {\n    node.removeChild(child);\n    context.markDeleted(/** @type {!Node}*/(child));\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  for (key in keyMap) {\n    child = keyMap[key];\n    if (!child.parentNode) {\n      context.markDeleted(child);\n      delete keyMap[key];\n    }\n  }\n\n  data.keyMapValid = true;\n};\n\n\n/** */\nexport {\n  alignWithDOM,\n  clearUnvisitedDOM\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getContext } from './context';\nimport { getData } from './node_data';\nimport {\n  enterTag,\n  exitTag\n} from './namespace';\n\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\n/**\n * Enters an Element, setting the current namespace for nested elements.\n * @param {Node} node\n */\nvar enterNode = function(node) {\n  var data = getData(node);\n  enterTag(data.nodeName);\n};\n\n\n/**\n * Exits an Element, unwinding the current namespace to the previous value.\n * @param {Node} node\n */\nvar exitNode = function(node) {\n  var data = getData(node);\n  exitTag(data.nodeName);\n};\n\n\n/**\n * Marks node's parent as having visited node.\n * @param {Node} node\n */\nvar markVisited = function(node) {\n  var context = getContext();\n  var walker = context.walker;\n  var parent = walker.getCurrentParent();\n  var data = getData(parent);\n  data.lastVisitedChild = node;\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nvar firstChild = function() {\n  var context = getContext();\n  var walker = context.walker;\n  enterNode(walker.currentNode);\n  walker.firstChild();\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextSibling = function() {\n  var context = getContext();\n  var walker = context.walker;\n  markVisited(walker.currentNode);\n  walker.nextSibling();\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar parentNode = function() {\n  var context = getContext();\n  var walker = context.walker;\n  walker.parentNode();\n  exitNode(walker.currentNode);\n};\n\n\n/** */\nexport {\n  firstChild,\n  nextSibling,\n  parentNode\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n    firstChild,\n    parentNode\n} from './traversal';\nimport { TreeWalker } from './tree_walker';\nimport {\n    getContext,\n    enterContext,\n    restoreContext\n} from './context';\nimport { clearUnvisitedDOM } from './alignment';\nimport { notifications } from './notifications';\n\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\nif (process.env.NODE_ENV !== 'production') {\n  var assertNoUnclosedTags = function(root) {\n    var openElement = getContext().walker.getCurrentParent();\n    if (!openElement) {\n      return;\n    }\n\n    var openTags = [];\n    while (openElement && openElement !== root) {\n      openTags.push(openElement.nodeName.toLowerCase());\n      openElement = openElement.parentNode;\n    }\n\n    throw new Error('One or more tags were not closed:\\n' +\n        openTags.join('\\n'));\n  };\n}\n\n\n/**\n * Patches the document starting at el with the provided function. This function\n * may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patch = function(node, fn, data) {\n  enterContext(node);\n\n  firstChild();\n  fn(data);\n  parentNode();\n  clearUnvisitedDOM(node);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(node);\n  }\n\n  getContext().notifyChanges();\n  restoreContext();\n};\n\n\n/** */\nexport {\n  patch\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  alignWithDOM,\n  clearUnvisitedDOM\n} from './alignment';\nimport { updateAttribute } from './attributes';\nimport { getData } from './node_data';\nimport { getContext } from './context';\nimport {\n    firstChild,\n    nextSibling,\n    parentNode\n} from './traversal';\nimport { symbols } from './symbols';\n\n\n// For https://github.com/esperantojs/esperanto/issues/187\nvar dummy;\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n\nif (process.env.NODE_ENV !== 'production') {\n  /**\n   * Keeps track whether or not we are in an attributes declaration (after\n   * elementOpenStart, but before elementOpenEnd).\n   * @type {boolean}\n   */\n  var inAttributes = false;\n\n\n  /** Makes sure that the caller is not where attributes are expected. */\n  var assertNotInAttributes = function() {\n    if (inAttributes) {\n      throw new Error('Was not expecting a call to attr or elementOpenEnd, ' +\n          'they must follow a call to elementOpenStart.');\n    }\n  };\n\n\n  /** Makes sure that the caller is where attributes are expected. */\n  var assertInAttributes = function() {\n    if (!inAttributes) {\n      throw new Error('Was expecting a call to attr or elementOpenEnd. ' +\n          'elementOpenStart must be followed by zero or more calls to attr, ' +\n          'then one call to elementOpenEnd.');\n    }\n  };\n\n\n  /**\n   * Makes sure that placeholders have a key specified. Otherwise, conditional\n   * placeholders and conditional elements next to placeholders will cause\n   * placeholder elements to be re-used as non-placeholders and vice versa.\n   * @param {string} key\n   */\n  var assertPlaceholderKeySpecified = function(key) {\n    if (!key) {\n      throw new Error('Placeholder elements must have a key specified.');\n    }\n  };\n\n\n  /**\n   * Makes sure that tags are correctly nested.\n   * @param {string} tag\n   */\n  var assertCloseMatchesOpenTag = function(tag) {\n    var context = getContext();\n    var walker = context.walker;\n    var closingNode = walker.getCurrentParent();\n    var data = getData(closingNode);\n\n    if (tag !== data.nodeName) {\n      throw new Error('Received a call to close ' + tag + ' but ' +\n            data.nodeName + ' was open.');\n    }\n  };\n\n\n  /** Updates the state to being in an attribute declaration. */\n  var setInAttributes = function() {\n    inAttributes = true;\n  };\n\n\n  /** Updates the state to not being in an attribute declaration. */\n  var setNotInAttributes = function() {\n    inAttributes = false;\n  };\n}\n\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Element}*/(alignWithDOM(tag, key, statics));\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    var attr, newAttrs = data.newAttrs;\n\n    for (attr in newAttrs) {\n      newAttrs[attr] = undefined;\n    }\n\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n    }\n  }\n\n  firstChild();\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function(tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    setInAttributes();\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n  }\n\n  argsBuilder.push(name, value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes();\n    setNotInAttributes();\n  }\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n    assertCloseMatchesOpenTag(tag);\n  }\n\n  parentNode();\n\n  var node = /** @type {!Element} */(getContext().walker.currentNode);\n\n  clearUnvisitedDOM(node);\n\n  nextSibling();\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function(tag, key, statics, var_args) {\n  var node = elementOpen.apply(null, arguments);\n  elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertPlaceholderKeySpecified(key);\n  }\n\n  var node = elementOpen.apply(null, arguments);\n  updateAttribute(node, symbols.placeholder, true);\n  elementClose.apply(null, arguments);\n  return node;\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function(value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes();\n  }\n\n  var node = /** @type {!Text}*/(alignWithDOM('#text', null));\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      formatted = arguments[i](formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  nextSibling();\n  return node;\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  elementPlaceholder,\n  text,\n  attr\n};\n"],"sourceRoot":"/source/"}